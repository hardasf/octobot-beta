// This file is autogenerated.
// Ideally it wouldn't exist, but it's here to test cjs in node
// Changes should go into ./test.js, and if new assertions are needed
// they'll need to be shimmed here as well
const tinycolor = require("./tinycolor.js");
const { Deno, testDefinitions } = require("@deno/shim-deno-test");
async function runDenoTests() {
  for (const test of testDefinitions) {
    if (test.ignore) {
      console.log(`Ignoring ${test.name}`);
      continue;
    }
    console.log(`Running ${test.name}`);
    await test.fn();
    console.log(`> Passed ${test.name}`);
  }
}
(async () => {
  const { assertEquals, assert, assertThrows } = await import(
    "../deno_asserts@0.168.0.mjs"
  );

  // TEST_BEGINS_HERE

Deno.test("TinyColor initialization", function () {
  assert(
    typeof tinycolor != "undefined",
    "tinycolor is initialized on the page"
  );
  assert(
    typeof tinycolor("red") == "object",
    "tinycolor is able to be instantiated"
  );

  var r = tinycolor("red");
  assert(
    tinycolor(r) === r,
    "when given a tinycolor instance, tinycolor() returns it"
  );
  assert(
    new tinycolor(r) === r,
    "when given a tinycolor instance, new tinycolor() returns it"
  );
  assertEquals(
    tinycolor("red", { format: "hex" }).toString(),
    "#ff0000",
    "tinycolor options are being parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0 }, { format: "hex" }).toString(),
    "#ff0000",
    "tinycolor options are being parsed"
  );

  var obj = { h: 180, s: 0.5, l: 0.5 };
  var color = tinycolor(obj);
  assert(
    obj.s === 0.5,
    "when given an object, the original object is not modified"
  );
});

Deno.test("Original input", function () {
  var colorRgbUp = "RGB(39, 39, 39)";
  var colorRgbLow = "rgb(39, 39, 39)";
  var colorRgbMix = "RgB(39, 39, 39)";
  var tinycolorObj = tinycolor(colorRgbMix);
  var inputObj = { r: 100, g: 100, b: 100 };
  var r = tinycolor("red");

  assert(
    tinycolor(colorRgbLow).getOriginalInput() === colorRgbLow,
    "original lowercase input is returned"
  );
  assert(
    tinycolor(colorRgbUp).getOriginalInput() === colorRgbUp,
    "original uppercase input is returned"
  );
  assert(
    tinycolor(colorRgbMix).getOriginalInput() === colorRgbMix,
    "original mixed input is returned"
  );
  assert(
    tinycolor(tinycolorObj).getOriginalInput() === colorRgbMix,
    "when given a tinycolor instance, the color string is returned"
  );
  assert(
    tinycolor(inputObj).getOriginalInput() === inputObj,
    "when given an object, the object is returned"
  );
  assert(
    new tinycolor("").getOriginalInput() === "",
    "when given an empty string, an empty string is returned"
  );
  assert(
    new tinycolor(null).getOriginalInput() === "",
    "when given a null value, an empty string is returned"
  );
});

Deno.test("Cloning color", function () {
  var originalColor = tinycolor("red");
  var originalColorRgbString = originalColor.toRgbString();

  var clonedColor = originalColor.clone();
  assert(
    clonedColor.toRgbString() === originalColor.toRgbString(),
    "cloned color is identical"
  );

  clonedColor.setAlpha(0.5);
  assert(
    clonedColor.toRgbString() !== originalColor.toRgbString(),
    "cloned color is changing independently from original color"
  );
  assert(
    originalColorRgbString === originalColor.toRgbString(),
    "original color was not changed by cloned color change"
  );
});
Deno.test("Random color", function () {
  var randomColor = tinycolor.random();
  assertEquals(randomColor.getAlpha(), 1);
  assertEquals(randomColor.getFormat(), "prgb");

  randomColor.setAlpha(0.5);
  assertEquals(randomColor.toHex8String().slice(-2), "80");
});

// Taken from convertWikipediaColors.html
var conversions = [
  {
    hex: "#FFFFFF",
    hex8: "#FFFFFFFF",
    rgb: { r: "100.0%", g: "100.0%", b: "100.0%" },
    hsv: { h: "0", s: "0.000", v: "1.000" },
    hsl: { h: "0", s: "0.000", l: "1.000" },
  },
  {
    hex: "#808080",
    hex8: "#808080FF",
    rgb: { r: "050.0%", g: "050.0%", b: "050.0%" },
    hsv: { h: "0", s: "0.000", v: "0.500" },
    hsl: { h: "0", s: "0.000", l: "0.500" },
  },
  {
    hex: "#000000",
    hex8: "#000000FF",
    rgb: { r: "000.0%", g: "000.0%", b: "000.0%" },
    hsv: { h: "0", s: "0.000", v: "0.000" },
    hsl: { h: "0", s: "0.000", l: "0.000" },
  },
  {
    hex: "#FF0000",
    hex8: "#FF0000FF",
    rgb: { r: "100.0%", g: "000.0%", b: "000.0%" },
    hsv: { h: "0.0", s: "1.000", v: "1.000" },
    hsl: { h: "0.0", s: "1.000", l: "0.500" },
  },
  {
    hex: "#BFBF00",
    hex8: "#BFBF00FF",
    rgb: { r: "075.0%", g: "075.0%", b: "000.0%" },
    hsv: { h: "60.0", s: "1.000", v: "0.750" },
    hsl: { h: "60.0", s: "1.000", l: "0.375" },
  },
  {
    hex: "#008000",
    hex8: "#008000FF",
    rgb: { r: "000.0%", g: "050.0%", b: "000.0%" },
    hsv: { h: "120.0", s: "1.000", v: "0.500" },
    hsl: { h: "120.0", s: "1.000", l: "0.250" },
  },
  {
    hex: "#80FFFF",
    hex8: "#80FFFFFF",
    rgb: { r: "050.0%", g: "100.0%", b: "100.0%" },
    hsv: { h: "180.0", s: "0.500", v: "1.000" },
    hsl: { h: "180.0", s: "1.000", l: "0.750" },
  },
  {
    hex: "#8080FF",
    hex8: "#8080FFFF",
    rgb: { r: "050.0%", g: "050.0%", b: "100.0%" },
    hsv: { h: "240.0", s: "0.500", v: "1.000" },
    hsl: { h: "240.0", s: "1.000", l: "0.750" },
  },
  {
    hex: "#BF40BF",
    hex8: "#BF40BFFF",
    rgb: { r: "075.0%", g: "025.0%", b: "075.0%" },
    hsv: { h: "300.0", s: "0.667", v: "0.750" },
    hsl: { h: "300.0", s: "0.500", l: "0.500" },
  },
  {
    hex: "#A0A424",
    hex8: "#A0A424FF",
    rgb: { r: "062.8%", g: "064.3%", b: "014.2%" },
    hsv: { h: "61.8", s: "0.779", v: "0.643" },
    hsl: { h: "61.8", s: "0.638", l: "0.393" },
  },
  {
    hex: "#1EAC41",
    hex8: "#1EAC41FF",
    rgb: { r: "011.6%", g: "067.5%", b: "025.5%" },
    hsv: { h: "134.9", s: "0.828", v: "0.675" },
    hsl: { h: "134.9", s: "0.707", l: "0.396" },
  },
  {
    hex: "#B430E5",
    hex8: "#B430E5FF",
    rgb: { r: "070.4%", g: "018.7%", b: "089.7%" },
    hsv: { h: "283.7", s: "0.792", v: "0.897" },
    hsl: { h: "283.7", s: "0.775", l: "0.542" },
  },
  {
    hex: "#FEF888",
    hex8: "#FEF888FF",
    rgb: { r: "099.8%", g: "097.4%", b: "053.2%" },
    hsv: { h: "56.9", s: "0.467", v: "0.998" },
    hsl: { h: "56.9", s: "0.991", l: "0.765" },
  },
  {
    hex: "#19CB97",
    hex8: "#19CB97FF",
    rgb: { r: "009.9%", g: "079.5%", b: "059.1%" },
    hsv: { h: "162.4", s: "0.875", v: "0.795" },
    hsl: { h: "162.4", s: "0.779", l: "0.447" },
  },
  {
    hex: "#362698",
    hex8: "#362698FF",
    rgb: { r: "021.1%", g: "014.9%", b: "059.7%" },
    hsv: { h: "248.3", s: "0.750", v: "0.597" },
    hsl: { h: "248.3", s: "0.601", l: "0.373" },
  },
  {
    hex: "#7E7EB8",
    hex8: "#7E7EB8FF",
    rgb: { r: "049.5%", g: "049.3%", b: "072.1%" },
    hsv: { h: "240.5", s: "0.316", v: "0.721" },
    hsl: { h: "240.5", s: "0.290", l: "0.607" },
  },
];

Deno.test("Color Equality", function () {
  for (var i = 0; i < conversions.length; i++) {
    var c = conversions[i];
    var tiny = tinycolor(c.hex);

    assert(true, tiny.isValid());
    assert(
      true,
      "Testing " +
        c.hex +
        ": " +
        tiny.toRgbString() +
        " " +
        tiny.toPercentageRgbString() +
        " " +
        tiny.toHsvString() +
        " " +
        tiny.toHslString() +
        " " +
        tiny.toHexString() +
        "Original: " +
        JSON.stringify(c.rgb) +
        " " +
        JSON.stringify(c.hsv) +
        " " +
        JSON.stringify(c.hsl)
    );
    assert(tinycolor.equals(c.rgb, c.hex), "RGB equals hex " + c.hex);
    assert(tinycolor.equals(c.rgb, c.hex8), "RGB equals hex " + c.hex);
    assert(tinycolor.equals(c.rgb, c.hsl), "RGB equals HSL " + c.hex);
    assert(tinycolor.equals(c.rgb, c.hsv), "RGB equals HSV " + c.hex);
    assert(tinycolor.equals(c.rgb, c.rgb), "RGB equals RGB " + c.hex);

    assert(tinycolor.equals(c.hex, c.hex), "hex equals hex " + c.hex);
    assert(tinycolor.equals(c.hex, c.hex8), "hex equals hex8 " + c.hex);
    assert(tinycolor.equals(c.hex, c.hsl), "hex equals HSL " + c.hex);
    assert(tinycolor.equals(c.hex, c.hsv), "hex equals HSV " + c.hex);

    assert(tinycolor.equals(c.hsl, c.hsv), "HSL equals HSV " + c.hex);
  }
});

Deno.test("With Ratio", function () {
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 1, b: 1 }).toHexString(),
    "#ffffff",
    "white"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: 0.5 }).toRgbString(),
    "rgba(255, 0, 0, 0.5)",
    "alpha works when ratio is parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: 1 }).toRgbString(),
    "rgb(255, 0, 0)",
    "alpha = 1 works when ratio is parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: 10 }).toRgbString(),
    "rgb(255, 0, 0)",
    "alpha > 1 works when ratio is parsed"
  );
  assertEquals(
    tinycolor.fromRatio({ r: 1, g: 0, b: 0, a: -1 }).toRgbString(),
    "rgb(255, 0, 0)",
    "alpha < 1 works when ratio is parsed"
  );
});

Deno.test("Without Ratio", function () {
  assertEquals(
    tinycolor({ r: 1, g: 1, b: 1 }).toHexString(),
    "#010101",
    "010101"
  );
  assertEquals(
    tinycolor({ r: 0.1, g: 0.1, b: 0.1 }).toHexString(),
    "#000000",
    "000000"
  );
  assertEquals(tinycolor("rgb .1 .1 .1").toHexString(), "#000000", "000000");
});

Deno.test("RGB Text Parsing", function () {
  assertEquals(
    tinycolor("rgb 255 0 0").toHexString(),
    "#ff0000",
    "spaced input"
  );
  assertEquals(
    tinycolor("rgb(255, 0, 0)").toHexString(),
    "#ff0000",
    "parenthesized input"
  );
  assertEquals(
    tinycolor("rgb (255, 0, 0)").toHexString(),
    "#ff0000",
    "parenthesized spaced input"
  );
  assertEquals(
    tinycolor({ r: 255, g: 0, b: 0 }).toHexString(),
    "#ff0000",
    "object input"
  );
  assertEquals(
    tinycolor({ r: 255, g: 0, b: 0 }).toRgb(),
    {
      r: 255,
      g: 0,
      b: 0,
      a: 1,
    },
    "object input and compare"
  );

  assert(tinycolor.equals({ r: 200, g: 100, b: 0 }, "rgb(200, 100, 0)"));
  assert(tinycolor.equals({ r: 200, g: 100, b: 0 }, "rgb 200 100 0"));
  assert(tinycolor.equals({ r: 200, g: 100, b: 0 }, "rgb 200 100 0"));
  assert(
    tinycolor.equals({ r: 200, g: 100, b: 0, a: 0.4 }, "rgba 200 100 0 .4")
  );
  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgba 200 100 0 1"));

  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgb(200, 100, 0)"));
  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgb 200 100 0"));
  assert(!tinycolor.equals({ r: 199, g: 100, b: 0 }, "rgb 200 100 0"));

  assert(
    tinycolor.equals(tinycolor({ r: 200, g: 100, b: 0 }), "rgb(200, 100, 0)")
  );
  assert(
    tinycolor.equals(tinycolor({ r: 200, g: 100, b: 0 }), "rgb 200 100 0")
  );
  assert(
    tinycolor.equals(tinycolor({ r: 200, g: 100, b: 0 }), "rgb 200 100 0")
  );
});

Deno.test("Percentage RGB Text Parsing", function () {
  assertEquals(
    tinycolor("rgb 100% 0% 0%").toHexString(),
    "#ff0000",
    "spaced input"
  );
  assertEquals(
    tinycolor("rgb(100%, 0%, 0%)").toHexString(),
    "#ff0000",
    "parenthesized input"
  );
  assertEquals(
    tinycolor("rgb (100%, 0%, 0%)").toHexString(),
    "#ff0000",
    "parenthesized spaced input"
  );
  assertEquals(
    tinycolor({ r: "100%", g: "0%", b: "0%" }).toHexString(),
    "#ff0000",
    "object input"
  );
  assertEquals(
    tinycolor({ r: "100%", g: "0%", b: "0%" }).toRgb(),
    {
      r: 255,
      g: 0,
      b: 0,
      a: 1,
    },
    "object input and compare"
  );

  assert(
    tinycolor.equals({ r: "90%", g: "45%", b: "0%" }, "rgb(90%, 45%, 0%)")
  );
  assert(tinycolor.equals({ r: "90%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));
  assert(tinycolor.equals({ r: "90%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));
  assert(
    tinycolor.equals(
      { r: "90%", g: "45%", b: "0%", a: 0.4 },
      "rgba 90% 45% 0% .4"
    )
  );
  assert(
    !tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgba 90% 45% 0% 1")
  );

  assert(
    !tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgb(90%, 45%, 0%)")
  );
  assert(!tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));
  assert(!tinycolor.equals({ r: "89%", g: "45%", b: "0%" }, "rgb 90% 45% 0%"));

  assert(
    tinycolor.equals(
      tinycolor({ r: "90%", g: "45%", b: "0%" }),
      "rgb(90%, 45%, 0%)"
    )
  );
  assert(
    tinycolor.equals(
      tinycolor({ r: "90%", g: "45%", b: "0%" }),
      "rgb 90% 45% 0%"
    )
  );
  assert(
    tinycolor.equals(
      tinycolor({ r: "90%", g: "45%", b: "0%" }),
      "rgb 90% 45% 0%"
    )
  );
});

Deno.test("HSL parsing", function () {
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38 }).toHexString(),
    "#2400c2",
    "to hex"
  );
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38 }).toRgbString(),
    "rgb(36, 0, 194)",
    "to rgb"
  );
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38 }).toHslString(),
    "hsl(251, 100%, 38%)",
    "to hsl"
  );
  assertEquals(
    tinycolor({ h: 251, s: 100, l: 0.38, a: 0.5 }).toHslString(),
    "hsla(251, 100%, 38%, 0.5)",
    "to hsla"
  );
  assertEquals(
    tinycolor("hsl(251, 100, 38)").toHexString(),
    "#2400c2",
    "to hex"
  );
  assertEquals(
    tinycolor("hsl(251, 100%, 38%)").toRgbString(),
    "rgb(36, 0, 194)",
    "to rgb"
  );
  assertEquals(
    tinycolor("hsl(251, 100%, 38%)").toHslString(),
    "hsl(251, 100%, 38%)",
    "to hsl"
  );
  assertEquals(
    tinycolor("hsl 100 20 10").toHslString(),
    "hsl(100, 20%, 10%)",
    "problematic hsl"
  );
});

Deno.test("Hex Parsing", function () {
  assertEquals(tinycolor("rgb 255 0 0").toHexString(), "#ff0000");
  assertEquals(tinycolor("rgb 255 0 0").toHexString(true), "#f00");

  assertEquals(tinycolor("rgba 255 0 0 0.5").toHex8String(), "#ff000080");
  assertEquals(tinycolor("rgb